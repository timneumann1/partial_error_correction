#the following functions were taken from the gen_alg_VQE code, done in 'AI for physicists', to detect entanglement generating blocks
#they were adapted to the case of the hackathon, where CZ and RZZ gates are applied

def detect_entangled_blocks(self):
    '''Identify entangled gate sequences using CZ and RZZ patterns'''
    blocks = []
    current_block = []

    for d in range(self.depth):
        layer_entanglement = set()
        for q in range(self.num_qubits):
            gate = self.circuit_matrix[q, d]
            # Check for CZ or RZZ gates
            if gate["name"] in ["CZ", "RZZ"]:
                # For CZ and RZZ, the qubits involved are the "control" and "target" (or equivalent)
                qubit_pair = tuple(sorted([gate["control_qubits"][0], gate["target_qubits"][0]]))
                layer_entanglement.add(qubit_pair)

        if layer_entanglement:
            layer_entanglement = frozenset(layer_entanglement)
            if not current_block or any(pair in layer_entanglement for pair in current_block[-1]):
                current_block.append(layer_entanglement)
            else:
                blocks.append(current_block)
                current_block = [layer_entanglement]
        else:
            if current_block:
                blocks.append(current_block)
                current_block = []

    return blocks

def find_commuting_block_pair(self, blocks1, blocks2):
        '''Find compatible crossover points using commutativity rules'''
        max_score = -1
        best_point = self.depth // 2  # Default midpoint
        
        for i in range(1, len(blocks1)):
            for j in range(1, len(blocks2)):
                # Score based on shared entanglement patterns
                score = len(set(blocks1[i]).intersection(blocks2[j]))
                if score > max_score:
                    max_score = score
                    best_point = min(i, j)  # Take earliest compatible point
        
        return best_point